
8 bit - 1 byte
2^10 byte - 1 KB
2^10 KB - 1 MB
2^10 MB - 1 GB

2^30 byte - 1 GB

2^32 == 2^30 * 2^2 = 4 GB



* Kernel 디렉토리 정리

arch - Architecture 의 약자

ARM, x86, c6x(TI DSP) 등등의 CPU Architecture 들을 볼 수 있다.
이 뜻은 결국 arch 디렉토리에는
사용하는 CPU 에 굉장히 민감한 코드들이 들어있음을 의미한다.
(즉, 어셈블리 코드들이 많이 들어있음)

include - 커널에서 사용하는 헤더 및 라이브러리들을 모아놓음

여기서 asm-generic 부분은 어셈블리와 관계되며
나머지 video 라든지 kvm, xen 등의 관련 코드들이 가볍게 존재함
(핵심 코드들은 여기 없고 위에 적었듯이 라이브러리 정도임)

lib - 커널에서 사용하는 알고리즘 코드들

대표적으로 Interrupt 를 처리하기 위한 Bottom Half 방식 및
커널의 메모리를 효율적으로 관리하기 위한 Red Black 트리 등이 존재

tools - 커널에서 사용하는 툴들

gpio, power, virtio 등이 대표적인 녀석들임
그리고 iio 라는 것이 있는데 무선 신호 디버깅과 관련이 있음

block - Block Device Driver 에서 사용하는 핵심 코드

이 부분의 소스 코드를 분석하면
Block Device Driver 들이 어떤식으로 동작하는지 파악할 수 있다.
하드디스크 부터 메모리, 그리고 USB, 등등
(물론 USB 는 MTD 라는 것을 추가적으로 공부해야함)

init - 초기화 코드들

이 부분에는 커널이 어셈블리 코드를 이빠이 구동시킨 이후
최초로 C 언어가 동작하게 되는 start_kernel() 코드가 존재함
여기서 각종 하드웨어 초기화 및 필요한 설정을 하게 된다.
Page Directory 설정 등도 여기서 함

samples - 커널 개발자들이 참고하라고 남겨놓은 찌꺼기

이 부분이 그들만의 리그라고 불리는 이유(밥줄이라서 그럴까 ?)
모르면 코드가 이해가 안되는 것들이 난무함
참고할만한 예제가 약간 있을 뿐(좋지 않음)

usr - User 와 관련된 부분으로 initramfs 와 관계됨

초기에 커널을 컴파일 한 이후에
유저가 사용할 유저 파일시스템이 필요한데
이 initramfs 부분과 관계된 코드가 존재함

certs - 인증과 관련된 코드가 존재함

Documentation - 한국 아재, 미국 아재등 개발자들이 적어놓은 문서

여기 잘 찾아보면 한국 아재가 적어놓은 명언이 있다.
"지금부터 시작이야 새끼야 공부 열심히 해라"
라는 문구를 찾아볼 수 있다.
여기에는 드라이버를 만드는 방법등
좋은 문서들이 많이 있다.
디바이스 드라이버를 개발할 때
참고할 수 있는 문서들이 방대하게 쌓여있다.

ipc - Inter Process Communication 코드가 존재함

Message Queue, Semaphore, Spinlock, Shared Memory 를
지원하기 위한 커널 함수가 들어있다.

scripts - 커널에서 활용할 수 있는 스크립트들이 존재함

스크립트란 컴파일 방식(정적)의 언어가 아닌
동적인 방식의 Interpreter(인터프리터)로 구동이됨
즉 Run-Time(CPU 구동시)에 코드가 변환되면서 구동함
(만들기 쉽고 단순한 작업에 용이함 - 복잡한 작업에 쓰면 뒷통수 맞음)

virt - 가상화의 핵심

KVM 이라고 Hypervisor(Virtual Machine Monitor) 개발과 관련된 코드
Cloud 서비스라고 불리는 것들이 사실 전부다 이 가상화다.
클라우드 서비스는 즉 커널 가상화 개발자들이 만드는 것
(국내는 서비스만 제공하고 실질적으로 만드는 곳은 없음)

drivers - Kernel 에서 사용하는 디바이스 드라이버들

디바이스 드라이버의 알고리즘은 block 등에 존재하지만
실질적인 제품의 드라이버 코드들은 여기에 존재함
(굉장히 많아서 필요한 것만 보고 구현하는 방식으로 해야함)

mm - Memory Management 를 수행하기 위한 핵심 코드

커널의 메모리 관리를 수행하는 코드들이 존재함
3개월차에 기회가 된다면 배우겠지만
Buddy 할당자와 Slab 할당자, 페이지 관리자,
가상 메모리 관리, 실행등의 전반을 관리하는 코드로 구성됨

security - 리눅스 시스템 보안과 관련됨

crypto - 암호학 공부한다면 보면 된다.

정수론과 굉장히 밀접하고
타원형 미분 방정식을 활용해서 암호 코드를 만들어내는
다양한 암호화 알고리즘들이 존재함(MD5, DES, AES 등등)

firmware - 칩 형태로 구동해야 하는 녀석들의 코드

Master, Slave 방식으로 펌웨어 코드들이 들어있음
통신은 UART 일 수도 있고 PCI 를 쓸 수도 있고 I2C 를 쓸 수도 있음

net - 리눅스 커널 코드의 33.3% 라 볼 수 있는 Network 부분

굉장히 방대한데 이유는 프로토콜이 겁나 많아서 그렇다.
그래서 Switch 나 Router 를 만들 경우
여기를 엄청나게 정리해야한다.
(필요한 프로토콜만 쓸 수 있도록 - 작업이 겁나 빡셈)
80211 같은 경우는 IEEE 표준의 802.11 로 무선을 의미함

sound - 소리와 관련된 라이브러리들이 존재함

Linux Kernel 에서는 이 부분을 ALSA 드라이버가 처리하게됨

fs - File System 의 약자

EXT2, EXT3, EXT4, NTFS, FAT, YAFFS 등등의
수천개에 해당하는 파일 시스템을 처리하는 코드들이 여기에 존재함
즉, open, read, write, close, lseek 코드도 여기 있음

kernel - Kernel 자체 코드가 있음

스케쥴링을 수행한다거나 Kernel Thread 를 만든다거나
Task 를 생성하거나 Context Switching 을
수행한다든지 하는 코드들이 전부 이 부분에 구현되어 있음
(물론 Context Switching 자체 코드는
 어셈블리어라서 어셈 arch 디렉토리도 같이 묶이게됨)



* 시그널(Signal)

Linux System Programming 에서 시그널이란
무선 신호나 전기 신호 등의 아날로그 신호를 의미하지 않는다.
그냥 프로그래밍 상에 약속된 용어 같은거라고 생각하면 되겠다.
뭐 ... 눈빛 교환도 일종의 시그널이라고 볼 수 있다.

abort() 는 SIGABRT 라는 신호를 발생시키고
자식 프로세스가 죽으면 SIGCHLD 라는 신호를 발생시킨다.
중요한 것은 signal 방식을 맞아서 프로그램이 종료되면
이것은 비정상 종료로 분류가 된다는 것이다.
어떤 신호를 맞아 죽었는지 판단을 할 필요가 생기게 된다.



* 실행 파일 포맷

윈도우는 PE 포맷, 리눅스는 ELF 포맷이라고 한다.
readelf 명령어는 리눅스의 실행 파일 포맷과 관련하여
실행 파일 자체를 굉장히 디테일하게 살펴볼 수 있게 해주는 명령어다.

실행 파일도 포맷을 가지고 있다보니
헤더, 바디(몸통), 그 외에 여러가지 섹션들을 가지고 있다.
우선 readelf -h '실행파일명' 을 수행하게 될 경우
ELF Header 라는 것을 볼 수 있는데
여기를 보면 실행 파일이 x86 용인지 ARM 용인지 확인할 수 있다.

Core Dump 에서 core 라는 파일도
포맷은 엄밀하게 ELF 에 해당하긴한다.
좀 더 자세한 부분은 커널을 하게 될 때 살펴보도록 하겠다.















