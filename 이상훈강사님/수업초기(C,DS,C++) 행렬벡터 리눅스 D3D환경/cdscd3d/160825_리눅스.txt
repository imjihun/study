ls /dev 	->리눅스 디바이스들
ls -l /dev	->리눅스 디바이스들 자세히

-, s, p, d, c, b, s등은 모두 파일의 종류를 나타낸다.
이 파일의 종류에 따라 동작 특성이 결정된다.

-	->실행파일 C파일등 일반 파일이다.
d	->dir
b	->블록 디바이스 드라이버
c	->캐릭터 디바이스 드라이버
p	->파이프
s	->소켓(여전히 남아있긴하지만 사라짐)->블록으로 넘어가게됨
l	->링크파일(바로가기파일)

캐릭터 디바이스 드라이버는 반드시 순서가 지켜져야함
	키보드(qwer넣고 스킬초기화 되서 qwer넣는데 순서가 안지켜지고 r부터 나오면 안된다)
	      (안녕을 입력하기위해서 ㅇㅏㄴㄴㅕㅇ순서대로 들어와야함)
	마우스(입력 순서대로 들어와야함)
	모니터(순서대로 실행되야함)(순서를 없애면 -> 카스 투명핵)


블록 디바이스 드라이버는 순서 따위는 지키지 않음
그러나 정해진 범위에서만 동작하게됨.
(물리메모리의 최소 단위는 페이지이며 4K이다.
 또한 대다수의 블록 디바이스들은 4K 블록을 유지한다.
 이유는 모든 내용이 메모리에 load되어야 하기 때문이다.)
	메모리등
	RAM(Random Access Memory)

//////////////////////////////////
2^12 = 4KB <- 	페이지의 최소단위
		DRAM의 최소단위
4KB씩 할당해야 하기 때문에 이런 크기가 정해져 있는것들은 블록디바이스이다.

8KB, 16KB가 최소단위면 속도를 올리고
4KB 밑이 최소단위면 공간활용



/////////////////////////////////////////////
{
 권한
 유저/유저가포함된그룹/제3자
 6/4/4

 그파일에 대한 link파일 개수

 uid 해당파일을 작성한 사람이 누구냐
 gid 유저가 속해있는 그룹이 어디냐(그룹이 없으면 uid와 gid가 같다)

 파일사이즈

 파일생성날짜

 파일 이름
}

rewinddir(dp)다시처음으로

chdir(dname);
dname을 현재 작업 디렉토리로 옮긴다.
../a.out을 해도 현재작업디렉토리는 저명령어를 친 위치이다.

set uid/set gid/sticky bit/rwxrwxrwx/ <-3+9 = 12bit
4/2/1

set uid부분
ls -l /usr/bin/ | grep sudo
-rwsr-xr-x <- x가 아니고 s를 가지면 강제적으로 루트권한을 준다.

set gid-> set uid랑 비슷
-rwxr-sr-x <- 그룹쪽에 s가 붙음


drwxrwxrwt <- t는 sticky bit
sticky bit가 붙으면 저디렉토리의 파일은 모두 공유가능
공유디렉토리

chmod 1755 a.out
하면 마지막 x 가 t로 바뀜
chmod 755 a.out하면 다시 x로 바뀜

chmod 2755는 그룹권한 s로
chmod 4755는 uid를 s로

setuid, setgid는 일시적으로 root의 권한을 빌릴 수 있음
그러나 sticky bit는 동작이 다소 특이함
디렉토리에 붙을 경우 공유 디렉토리를 만들게됨
파일에 붙을 경우에는 내일 2시간에 걸쳐 설명할
페이징과 관계된 굉장히 복잡한 연산과 관계가 있음
(쉽게 한마디로 정리하게 되면 성능을 높여줌)

//top <- 리눅스 명령어 윈도우컨트롤알트델레트

Fork() <- 시스템콜
부모프로세스				자식프로세스
text					text
data					data
heap			-복사->		heap
shared memory				shared memory
stack					stack
복사된 시점은 fork()가 쓰여진 시점

fork()자식이 있으면 자식의 pid값을 가져오고 자식이 없으면 0을 리턴



프로그램실행 조차도 커널에서 프로세스 승인을 해줘야 실행가능


1,2
3,4,5,6
7,8,9,10,11,
12,13,14,15,16,17,18,19,20