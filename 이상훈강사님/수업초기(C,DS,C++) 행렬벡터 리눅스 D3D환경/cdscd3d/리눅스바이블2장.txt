2.12 Threads
현대 유닉스 구현에서, 각 프로세스는 실행된 여러개의 스레드를 가질 수 있습니다.
쓰레드를 예상하는 방법중 하나는 동일한 가상메모리뿐만 아니라 다른 특성의 범위를 공유하는 프로세스set이다.
각 스레드가 같은 프로그램 코드를 실행하면서 동일한 데이터영역과 힙을 공유한다.
하지만 각 쓰레드는 함수호출 연관정보와 지역변수를 포함하는 자신의 스택을 가진다.
스레드는 공유하는 전역변수를 통해 서로 통신할수 있다.
스레딩 API는 그 동작(특히, 공유 변수의 사용)을 동기화하고 통신하기 위한 프로세스의 스레드를 활성화시키는 처음에 조건 변수와 뮤텍스를 제공한다.
스레드도 서로 2.10에 설명된 그 IPC와 동기화 메커니즘을 사용하여 통신할수 있다.
스레드를 사용하는 주된 장점은 협동하는 쓰레드들끼리 (전역변수를 사용한)데이터 공유가 쉽다는 것과 어떤 알고리즘이 멀티쓰레드구현으로 멀티프로세스구현보다 좀 더 내츄럴리 하게 바꾼다.
또한 멀티스레드 어플리케이션은 멀티프로세서하드웨어로 병렬프로세싱을 위한 가능성의 장점을 투명하게 취할수 있다.

2.13 프로세스그룹과 쉘잡컨트롤
쉘에의해 실행된 각각 프로그램은 새로운 프로세스로 시작된다. 예를들어 다음예제는 그 쉘은 명령어 파이프라인을 따라서 실행하기 위해 3개의 프로세스를 생성한다.
(현재 작업중인 디렉토리에서 파일사이즈별로 정렬된 파일 리스트를 출력한다)
ls -l | sort -k5n | less
Bourne shell을 제외한 모든 주요 쉘은 유저가 동시에 실행할수 있고, 여러 명령어나 파이프라인을 조작할수 있도록 잡컨트롤이라고 불리는 대화형 기능을 제공합니다.
잡컨트롤쉘에서, 파이프라인의 모든 프로세스들은 새로운 프로세스그룹이나 작업에 배치된다.(간단한 예로 쉘명령어라인은 하나의 명령어를 포함하고,  단하나의 만들어진 프로세스를 포함하는 새로운 프로세스그룹을 포함한다.)
프로세스 그룹의 각 프로세스는 같은 정수 프로세스 그룹 식별자(그룹의 리더프로세스ID)를 갖는다.
그 커널은 프로세스 그룹의 모든 멤버가 수행하는 변수 행동(특히 시그널전달)을 하도록 허락한다.
잡컨트롤쉘은 유저에게 모든 파이프라인에 그 프로세스를 중지나 재개를 하도록 허락하는것을 사용한다. 다음섹션에 설명되었다.

2.14 세션, 컨트롤링터미널, 컨트롤링프로세스
세션은 프로세스그룹(작업들)의 집합이다. 세션에 모든 프로세스들은 같은 세션식별자를 갖는다. 세션리더는 그 세션에게 생성해준 프로세스다. 그리고 그 프로세스ID는 세션ID가 된다.
세션들은 보통 관련된 컨트롤링터미널을 갖는다. 그 컨트롤링터미널은 그 세션리더프로세스가 어떤 터미널디바이스를 처음 열때 확립된다. 어떤 대화형쉘에 의해 생성된 어떤 세션은 그 유저가 접속한 터미널이다.대부분 하나의 세션에서 어떤 터미널은 아마 컨트롤링터미널일 것이다.
컨트롤링터미널을 오픈한 결과로, 그 세션리더는 그 터미널을 위한 컨트롤링프로세스가 된다. 그 컨트롤링 프로세스는 어떤 터미널의 연결이 끊겼다면(예를들어, 그 터미널윈도우가 닫혔다면) SIGHUP 시그널을 받는다.
이때, 세션중 하나의 프로세스 그룹은 그 터미널로 아웃풋을 전달하고 입력을 받을 foreground process group(foreground job) 이다. 만약 그유저가 인터럽트문자(컨트롤씨)나 서스펜드문자(컨트롤제트)를 입력한다면 그 터미널 드라이버는 죽이거나 서스펜드하라는(i.e., 스탑) 신호를 foreground process그룹에게 보낼것이다. 세션은 &문자를 가진 명령어를 종료함으로써 생성된 백그라운드프로세스그룹(백그라운드잡)들의 숫자를 가질수 있다. 
잡컨트롤쉘은 작업에 신호를 전달하거나  포그라운드와 백그라운드 사이를 작업이 이동되거나 모든작업을 목록화 하기위한 명령어를 제공한다.

2.15 수도터미널
수도터미널은 연결된 가상디바이스 쌍이다. master와 slave로 불린다. 이 디바이스쌍은 두 디바이스 사이에 양방향으로 통신되는 데이터들이 통과하는 IPC 채널을 제공한다.
수도터미널에대한 그 키포인트는 slave디바이스가 터미널같이 동작하는 인터페이스를 제공한다. 그 터미널은 터미널지향 프로그램이 slave디바이스에게 연결하는 것을 가능하게 해주고 나서 master디바이스에게 연결된 또다른 프로그램을 터미널지향 프로그램을 다루기 위해 사용한다. 드라이버프로그램에 의한 출력은 그터미널드라이버에 의해 수행된 일반적인 입력을 받는다.(예를들어, 기본모드에서, 캐리지리턴은 뉴라인으로 맵핑된다.) 그리고 그 출력은 slave와 연결된 그 터미널지향프로그램에게 입력으로 전달된다.그 터미널지향프로그램이 slave에게 쓰는 어떤것이든 (보통의 터미널출력과정을 모두 수행한 후에) 그 드라이버프로그램의 입력으로 전달된다. 즉,그 드라이버프로그램은 일반적인 터미널에서 보통의 유저가 구현한 함수들을 수행한다.
다양한 어플리케이션에 사용되는 수도터미널은 다양한 어플리케이션에서 사용된다.(특히 X윈도우시스템 로그인에서와 네트워크로그인 서비스를 제공하는 어플리케이션에서(telnet과 ssh와 같은)제공되는 터미널 윈도우의 구현에서)

2.16 데이터와 타임
타임의 두가지 유형은 프로세스와 관련이 있다.
1.리얼타임은 어떤 표준시점(캘린더타임)이나 어떤 고정된 시점에서 잰거다. 일반적으로 그 시작은 프로세스의 라이프에서(시간흐름이나 벽시계시간) 시작. 유닉스 시스템에서 캘린더타임(UTC(Universal Coordinated TIme))은 1970년 1월 1일의 아침에 자정이후부터 초로 잰거다. 그리고 영국의 그리니치를 통하는 경도에 의해 정의된 타임존을 베이스로 조정한다. 이 날짜는 유닉스를 만든 날짜와 가깝다.
2. CPU타임이라고도 불리는 프로세스타임은 프로세스가 시작한이래로의 CPU타임의 시간이다. CPU타임은 시스템CPU타임과 유저CPU타임으로 더 세분화될수 있다. 그 시스템CPU타임은 커널모드(예로 시스템콜을 실행하거나 프로세스대신 다른 커널서비스를 수행하는것) 에서 코드를 실행하면서 소비하는 시간, 그리고 유저CPU타임은 유저모드(보통 프로그램코드를 실행하는것)에서 코드를 실행하면서 소비하는 시간이다.

그 time명령어는 파이프라인에서 프로세스를 실행하면서 걸린 리얼타임, 시스템CPU타임, 유저CPU타임을 표시한다.

2.17client-server Architecture
이 접근 방식은 시뮬레이션이 고성능 컴퓨터 클러스터 또는 다중 코어 워크스테이션 또는 메인프레임 컴퓨터에서 수행되고 있는 동안, STAR-CCM+ 클라이언트는 일반 랩톱 또는 데스크톱 같은 경량의 원격 컴퓨터에서 데이터를 분석하는 데 사용될 수 있음을 의미합니다. 네트워크 트래픽은 최소로 유지되는데 이는 컴퓨터 시설이 지리적으로 원격지에 있더라도 시뮬레이션이 제어될 수 있어 완전히 유연한 작업 환경을 가능하게 할 수 있음을 의미합니다. 팀원들은 또한 복수의 클라이언트를 단일 STAR-CCM+ 서버에 연결하여 공조할 수도 있습니다.

